## 编译器（Compiler）&&解释器 （Interpreter）

1. 编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。
2. 编译型语言就是在代码执行之前需要编译，通过编译器之后生成的二进制文件，这样每次运行程序得时候，都可以直接运行该二进制文件。例如 C/C++、Go
3. 而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言
4. 编译型器: 
    >源代码(词法分析/语法分析)——>AST(词意分析)——>中间代码(代码优化)——>二进制文件(直接执行)——>执行
5. 解释器:
    >源代码(词法分析/语法分析)——>AST(词意分析)——>字节码(解释执行)——>执行
6. 编译型语言优缺点
    1. 优点是快快快，因为程序在编译期，已经被预先编译成机器代码，可以直接执行，不用像解释型语言一样，还要多一道直译程序
    2. 缺点不适合跨平台(理解为不同CPU架构（例如X86、ARM等）的机器和同种CPU但不同的操作系统（例如Unix、Windows等）的机器 ),因为想在不同CPU的机器或者系统上运行编译型语言的源代码，就需要针对不同的CPU架构和操作系统进行编译
7. 解释型语言优缺点
    1. 相对编译型慢,因为解释型语言的每一句源代码都要经过解释器解释为可以执行的机器指令
    2. 优点是跨平台好，

8. 不过现在有JIT技术，两者速度慢慢缩小

# V8 是如何执行一段 JavaScript 代码的

一、抽象语法树（AST）
1. 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串
2. 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。
3. 例如Babel就是利用AST将ES6得源码转为AST,然后再将ES6的AST转为ES5的AST,最后转为源代码

二、生成字节码
1. 原先是没有字节码的，而是直接把AST转为机器码，但是由于chrome在手机上广泛普及，内存问题越来越显著，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码。

三、 执行代码
1. 执行代码: 通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行,解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。JIT(即时编译)

2. 对于3.4的理解:首先机器码的内存占有率会很大，但是它的执行效率会更高，那么带来新的问题，因为编译器生成的机器码越多，那么内存占有率越来越高
