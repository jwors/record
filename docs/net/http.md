# 网络分层
1. OSI 模型： 应用层、会话层、表示层、传输层、网络层、数据链路层、物理层
2. TCP/IP 模型： 应用层、传输层、网络层、数据链路层、物理层


# http https 相关知识点

1. http协议是无状态、灵活 、无连接，存在于应用层
2. 状态码分类
    1. 1xx  表示处理中的中间状态，需要后面进一步操作
    2. 2xx  成功
    3. 3xx  重定向
        1. 301 永久重定向
        2. 302 临时重定向
        3. 304 缓存重定向
    4. 4xx 客户端请求错误
        1. 400 笼统的客户端错误
        2. 401 请求凭证不对
        3. 403 服务器禁止访问资源
        4. 404 请求的资源未找到
        5. 405 请求方式不对
    5. 5xx 服务端错误
        1. 501 表示服务器不支持该请求方法 
        2. 505 表示服务器不支持该http 版本 

3. 缓存机制
   1. 流程：浏览器请求资源,判断是否有缓存信息，如果没有就请求服务器，如果有，就先判断是否明中强缓存，如果命中就获取缓存信息,若是没有，就请求服务器判断是否命中协商缓存，命中则就获取，没有命中就服务器传输资源

4. 强缓存 (请求响应头)
   1. Cache-control 
   2. Expires 缺点： 服务器时间和浏览器时间会不一致
   3. 上述两者同时存在，就以Cache=control为准

5. 协商缓存 (请求响应头)
    1. Last-Modified If-Modified-Since 表示资源修改时间 缺点是精度不够，只能到秒
    2. Etag 和 If-None-Match 资源内容标识优先级高，

6. request method
    1. get: 会被缓存 有长度限制 （2048字符）  幂等 请求参数在url上
    2. post: 不会被缓存 无限制 非幂等  请求体内

7. HTTP/1.1 相⽐ HTTP/1.0 性能上的改进
    1. 使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销
    2. ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间


8. HTTP/1.1 还是有性能瓶颈
    1. 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；
    2. 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；
    3. 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
    4. 没有请求优先级控制；
    5. 请求只能从客户端开始，服务器只能被动响应。 

9. http 2.0 对于 1.1 优化
   1. 头部压缩
   2. 二进制格式
   3. 数据流
   4. 服务器推送
   5. 多路复用， <b>⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应 </b> 移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率
   6. 1.1 的 请求是需要一一对应的，前面的请求没处理好，后面的就得等待

10. https大致就是加一层SSL,由之前HTTP先和SSL通信，然后 SSL(SSL 和 TLS 是同一个东西的不同阶段) 和 TPC 通信

# TCP UDP 相关知识点

1. 三次握手
   1. 目的:是为了保证双方信息发送和接受的能力
   2. 过程
      1. 浏览器发送一个 SYN seq num = client_isn
      2. Server 发送一个 SYN+ACK ,然后再 client_isn + 1，再补充一个 server_isn
      3. Client 发送一个 ACK 和 server_isn + 1 ,这一步可以传输数据

2. 四次挥手
   1. Client 发送一个FIN 为 1的报文，此时 Client 进入 FIN_WAIT_1
   2. Server 发送一个 ACK 报文， Server 进入 CLOSE_WAIT 状态，当客户端收到ACK 报文之后，变为 FIN_WAIT_2
   3. 服务端处理完数据之后， Server  发送一个 FIN 报文，服务端进入LAST_ACK 状态
   4. 客户端收到服务端的 FIN 报文后， 回一个 ACK 应答报文，之后进入 TIME_WAIT 状态，服务端进入 CLOSED 状态
   5.  <b>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接</b>

8. MSL
    > MSL 的意思是 <b>报文最大生存时间</b>

4. TTL
    > 报可以经过的最⼤路由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃  

5. 二者区别：MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 MSL 应该要⼤于等于 TTL 消耗为 0 的时间，以确保报⽂已被⾃然消亡 

6. 客户端为什么要等待2MSL
    > ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。

7. TCP
    1. 面向链接 ———— 一定是一对一
    2. 可靠的 ———— ⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端
    3. 字节流 ———— 消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃

8. UDP
   1. 无需链接就可以传输
   2. 不可靠的
   3. 传输方式是一个包一个包发送的，会有丢失

9. 使用场景
    1. TCP: FTP文件传输、http/https
    2. UDP: 包总数小的通信

10. 1 ~ 9 来自于 [小林Coding](https://xiaolincoding.com/)


  

